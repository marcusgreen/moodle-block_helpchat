{"version":3,"file":"dom_parser.min.js","sources":["../src/dom_parser.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Extract DOM elements and export them as JSON.\n\n * @module     block_helpchat/js_dom_parser\n * @author     2025 Marcus Green\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\n/**\n * Get DOM elements inside #page-content and return as JSON.\n *\n * This function scans the page content for form elements and extracts their properties,\n * including values, labels, help text, and complex dependencies between elements.\n * It supports all major form input types and analyzes their relationships.\n * Based closely on work by Dr Peter Mayer ByCS\n *\n * @returns {Promise<Object>} Promise that resolves to JSON object containing structured form element data with dependencies\n */\nexport const getDomElementsAsJson = () => {\n    return new Promise((resolve) => {\n        resolve(extractDomElements());\n    });\n};\n\n/**\n * Internal function to extract DOM elements after all scripts have executed.\n *\n * @returns {Object} JSON object containing structured form element data with dependencies\n */\nconst extractDomElements = () => {\n    const elements = [];\n\n    // Find the main content container - all Moodle forms are within #page-content.\n    const contentDiv = document.getElementById('page-content');\n    if (!contentDiv) {\n        // Return empty structure if no content area is found.\n        return {};\n    }\n\n    // Comprehensive selector for all form input types including hidden fields and buttons.\n    // This covers standard inputs, textareas, selects, and special Moodle form elements.\n    const selector =\n        'input[type=\"text\"], input[type=\"password\"], input[type=\"email\"], input[type=\"number\"], ' +\n        'input[type=\"search\"], input[type=\"tel\"], input[type=\"url\"], input[type=\"date\"], ' +\n        'input[type=\"datetime-local\"], input[type=\"checkbox\"], input[type=\"radio\"], input[type=\"file\"], ' +\n        'input[type=\"hidden\"], input[type=\"submit\"], input[type=\"button\"], textarea, select';\n\n    const domNodes = contentDiv.querySelectorAll(selector);\n\n    // Process each form element found in the DOM.\n    domNodes.forEach((node) => {\n        let type = node.tagName.toLowerCase();\n        let currentValue = '';\n        const options = [];\n\n        // Extract current value based on element type and special handling for different inputs.\n        if (type === 'input') {\n            type = node.type;\n            if (type === 'checkbox' || type === 'radio') {\n                // For checkboxes and radios, return the value only if checked, otherwise empty.\n                currentValue = node.checked ? node.value || 'on' : '';\n            } else {\n                // For all other input types, get the current value.\n                currentValue = node.value || '';\n            }\n        } else if (type === 'textarea') {\n            type = 'textarea';\n\n            // Special handling for TinyMCE editors which are hidden textareas with iframe content.\n            if (node.style.display === 'none' && node.id) {\n                const tinyFrame = document.querySelector(`#${node.id}_ifr`);\n                if (tinyFrame?.contentDocument) {\n                    try {\n                        // Extract content from TinyMCE iframe body.\n                        const tinyBody = tinyFrame.contentDocument.body;\n                        currentValue = tinyBody ? (tinyBody.textContent || tinyBody.innerText || '') : node.value || '';\n                    } catch (e) {\n                        // Fallback to textarea value if iframe access fails (cross-origin issues).\n                        currentValue = node.value || '';\n                    }\n                } else {\n                    currentValue = node.value || '';\n                }\n            } else {\n                // Standard textarea handling.\n                currentValue = node.value || '';\n            }\n        } else if (type === 'select') {\n            type = 'select';\n\n            // Get selected value from select element.\n            currentValue = node.selectedOptions?.length > 0 ? node.selectedOptions[0].value : (node.value || '');\n\n            // Check if this select is within a date_time container to avoid verbose output.\n            if (!isWithinDateTimeContainer(node)) {\n                const optionElements = node.querySelectorAll('option');\n                optionElements.forEach((option) => {\n                    options.push({\n                        value: option.value,\n                        text: option.textContent || option.innerText || '',\n                        selected: option.selected\n                    });\n                });\n            }\n        }\n\n        // Find the associated label text using multiple strategies for Moodle form conventions.\n        const label = findLabelForElement(node);\n\n        // Extract help text/description that provides additional context for the field.\n        const helptext = findHelptextForElement(node);\n\n        // Determine if the element is currently active/enabled (1) or disabled (0).\n        let active = 1;\n        let isDisabled = false;\n        let dependsOnEnabled = null;\n\n        // Check element disabled state using multiple methods to ensure compatibility.\n        // Method 1: Check the disabled property directly.\n        if (node.disabled === true) {\n            isDisabled = true;\n        }\n\n        // Method 2: Check for disabled attribute (covers cases like <select disabled> and <select disabled=\"disabled\">).\n        const attrNode = node.getAttributeNode?.('disabled');\n        if (attrNode?.specified) {\n            isDisabled = true;\n        }\n\n        // Check if element is hidden via CSS styles (but not for hidden input types).\n        const computedStyle = window.getComputedStyle(node);\n        if (computedStyle.display === 'none' && type !== 'hidden') {\n            active = 0;\n        } else {\n            active = isDisabled ? 0 : 1;\n        }\n\n        // Determine visual visibility based on computed styles.\n        const isVisuallyVisible = getElementVisualVisibility(node, computedStyle);\n\n        // Check for Moodle-specific _enabled checkbox dependencies (legacy support).\n        const enabledDependency = checkEnabledDependency(node);\n        if (enabledDependency) {\n            dependsOnEnabled = enabledDependency.checkboxName;\n            // If the controlling _enabled checkbox is not checked, mark element as inactive.\n            if (!enabledDependency.isEnabled) {\n                active = 0;\n            }\n        }\n\n        // Analyze all possible dependencies (select-based, checkbox-based, radio-based).\n        const allDependencies = checkElementDependencies(node);\n\n        // Analyze JavaScript-based dependencies (CSS classes, event handlers).\n        const jsDependencies = analyzeJavaScriptDependencies(node);\n\n        // Analyze relationships with sibling elements (similar names, numeric series).\n        const siblingDependencies = analyzeSiblingDependencies(node);\n\n        // Build the element data object with all extracted information.\n        const elementData = {\n            id: node.id || '',\n            name: node.name || '',\n            type: type,\n            current_value: currentValue,\n            label: label,\n            helptext: helptext,\n            active: active,\n            visible: isVisuallyVisible\n        };\n\n        // Add checked status for checkbox and radio elements.\n        if (type === 'checkbox' || type === 'radio') {\n            elementData.checked = node.checked || false;\n        }\n\n        // Add legacy _enabled dependency information if present.\n        if (dependsOnEnabled) {\n            elementData.depends_on_enabled = dependsOnEnabled;\n        }\n\n        // Add comprehensive dependency analysis if any dependencies were found.\n        if (allDependencies) {\n            elementData.dependencies = allDependencies;\n        }\n\n        // Add JavaScript-based dependency information if detected.\n        if (jsDependencies) {\n            elementData.js_dependencies = jsDependencies;\n        }\n\n        // Add sibling relationship information if similar elements were found.\n        if (siblingDependencies) {\n            elementData.sibling_dependencies = siblingDependencies;\n        }\n\n        // Add select options only for select elements (excluding verbose date/time selects).\n        if (type === 'select' && options.length > 0) {\n            elementData.options = options;\n        }\n\n        // Add the processed element to the collection.\n        elements.push(elementData);\n    });\n\n    return elements;\n};\n\n/**\n * Find label text for a given form element.\n *\n * This function implements multiple strategies to locate label text for form elements,\n * following Moodle's form conventions and standard HTML practices.\n *\n * @param {HTMLElement} element - The form element to find a label for\n * @returns {string} The label text, or empty string if no label is found\n */\nconst findLabelForElement = (element) => {\n    let label = '';\n\n    // Strategy 1: Explicit label with for attribute pointing to element's ID.\n    // This is the most reliable method when elements have proper IDs.\n    if (element.id) {\n        const labelElement = document.querySelector(`label[for=\"${element.id}\"]`);\n        if (labelElement) {\n            label = labelElement.textContent || labelElement.innerText || '';\n            label = label.trim();\n        }\n    }\n\n    // Strategy 2: Parent label element that wraps the input.\n    // Some forms use <label><input></label> structure instead of for/id association.\n    if (!label) {\n        const parentLabel = element.closest('label');\n        if (parentLabel) {\n            label = parentLabel.textContent || parentLabel.innerText || '';\n            label = label.trim();\n        }\n    }\n\n    // Strategy 3: Moodle-specific form structure with Bootstrap classes.\n    // Moodle forms use .fitem containers with .col-form-label sections.\n    if (!label) {\n        const fitemDiv = element.closest('.fitem');\n        if (fitemDiv) {\n            // Look for labels in the Bootstrap form structure used by Moodle.\n            const labelDiv = fitemDiv.querySelector('.col-form-label label, .col-form-label p');\n            if (labelDiv) {\n                label = labelDiv.textContent || labelDiv.innerText || '';\n                label = label.trim();\n            }\n        }\n    }\n\n    // Strategy 4: Accessibility attributes as fallback.\n    // Use aria-label or title attributes when no visible label is found.\n    if (!label) {\n        label = element.getAttribute('aria-label') || element.getAttribute('title') || '';\n    }\n\n    return label;\n};\n\n/**\n * Find helptext for a given form element.\n *\n * Searches for help text associated with form elements, typically found in\n * Bootstrap popover data attributes in Moodle forms.\n *\n * @param {HTMLElement} element - The form element to find help text for\n * @returns {string} The help text content, or empty string if none is found\n */\nconst findHelptextForElement = (element) => {\n    let helptext = '';\n\n    // Define containers to search in hierarchical order from specific to general.\n    const searchContainers = [\n        element.parentElement,           // Direct parent first.\n        element.closest('.fitem'),       // Moodle form item container.\n        element.closest('.felement'),    // Moodle form element wrapper.\n        element.closest('.col-md-9')     // Bootstrap column containing the input.\n    ];\n\n    // Search each container for help content in Bootstrap popovers.\n    for (const container of searchContainers) {\n        if (container) {\n            // Look for help icons with Bootstrap popover data.\n            const helpAnchor = container.querySelector('a[data-bs-content]');\n            if (helpAnchor?.getAttribute('data-bs-content')) {\n                const rawHelp = helpAnchor.getAttribute('data-bs-content');\n\n                // Clean HTML content from the popover to get plain text.\n                const tmpDiv = document.createElement('div');\n                tmpDiv.innerHTML = rawHelp;\n                helptext = tmpDiv.textContent || tmpDiv.innerText || '';\n                helptext = helptext.trim();\n                break;\n            }\n        }\n    }\n\n    return helptext;\n};\n\n/**\n * Check if an element depends on an _enabled checkbox.\n *\n * This function implements Moodle's convention where form elements can be controlled\n * by associated _enabled checkboxes. This pattern is commonly used in assignment\n * plugins and other areas where features can be enabled/disabled.\n *\n * @param {HTMLElement} element - The form element to check for _enabled dependencies\n * @returns {Object|null} Object with checkboxName and isEnabled, or null if no dependency\n */\nconst checkEnabledDependency = (element) => {\n    const elementName = element.name || element.id || '';\n\n    // Define various patterns for _enabled checkbox naming conventions.\n    const patterns = [\n        // Direct match: element_name -> element_name_enabled.\n        `${elementName}_enabled`,\n        // Partial match: some_element_option -> some_element_enabled.\n        elementName.replace(/_[^_]+$/, '_enabled'),\n        // Group patterns: like allowsubmissionsfromdate[day] -> allowsubmissionsfromdate[enabled].\n        elementName.replace(/\\[[^\\]]+\\]$/, '[enabled]')\n    ];\n\n    // Generate additional patterns by analyzing element name structure.\n    const nameParts = elementName.split('_');\n    if (nameParts.length > 1) {\n        // Example: assignsubmission_file_maxfiles -> assignsubmission_file_enabled.\n        for (let i = nameParts.length - 1; i >= 2; i--) {\n            const baseName = nameParts.slice(0, i).join('_');\n            patterns.push(`${baseName}_enabled`);\n        }\n    }\n\n    // Define search containers in order of specificity.\n    const searchContainers = [\n        element.closest('.fitem'),       // Immediate form item container.\n        element.closest('fieldset'),     // Fieldset grouping.\n        element.closest('.fcontainer'),  // Form container.\n        document.getElementById('page-content')  // Page-wide search as fallback.\n    ];\n\n    // Search for _enabled checkboxes using generated patterns.\n    for (const enabledName of patterns) {\n        for (const container of searchContainers) {\n            if (!container) {\n                continue;\n            }\n\n            // Look for checkbox with matching name or ID.\n            let enabledCheckbox = container.querySelector(\n                'input[type=\"checkbox\"][name=\"' + enabledName + '\"], ' +\n                'input[type=\"checkbox\"][id*=\"' + enabledName.replace(/[\\[\\]]/g, '_') + '\"]'\n            );\n\n            if (enabledCheckbox) {\n                return {\n                    checkboxName: enabledName,\n                    checkboxId: enabledCheckbox.id,\n                    isEnabled: enabledCheckbox.checked\n                };\n            }\n        }\n    }\n\n    // Special handling for Moodle form groups like fgroup_id_submissionplugins.\n    let fitemContainer = element.closest('.fitem');\n    if (fitemContainer) {\n        let fgroupMatch = fitemContainer.id && fitemContainer.id.match(/^fgroup_id_(.+)$/);\n        if (fgroupMatch) {\n            // Search for related _enabled checkboxes within the same group.\n            let groupCheckboxes = fitemContainer.querySelectorAll('input[type=\"checkbox\"][name*=\"_enabled\"]');\n            for (let gc = 0; gc < groupCheckboxes.length; gc++) {\n                let groupCheckbox = groupCheckboxes[gc];\n                let checkboxName = groupCheckbox.name;\n\n                // Check if the element name matches the checkbox pattern.\n                if (elementName.indexOf(checkboxName.replace('_enabled', '')) === 0) {\n                    return {\n                        checkboxName: checkboxName,\n                        checkboxId: groupCheckbox.id,\n                        isEnabled: groupCheckbox.checked\n                    };\n                }\n            }\n        }\n    }\n\n    return null;\n};\n\n/**\n * Check if a select element is within a date_time container.\n *\n * Date/time fields in Moodle often have many select options (days, months, years, hours, minutes)\n * which would clutter the output. This function identifies such containers to exclude their options.\n *\n * @param {HTMLElement} element - The select element to check\n * @returns {boolean} True if the element is within a date_time container\n */\nconst isWithinDateTimeContainer = (element) => {\n    // Search for parent element with data-fieldtype=\"date_time\" attribute.\n    const dateTimeContainer = element.closest('[data-fieldtype=\"date_time\"]');\n    if (dateTimeContainer) {\n        return true;\n    }\n\n    // Additional search for fieldset with date_time fieldtype.\n    const fieldsetContainer = element.closest('fieldset[data-fieldtype=\"date_time\"]');\n    if (fieldsetContainer) {\n        return true;\n    }\n\n    // Search for div or other containers with date_time fieldtype.\n    const divContainer = element.closest('div[data-fieldtype=\"date_time\"]');\n    if (divContainer) {\n        return true;\n    }\n\n    return false;\n};\n\n/**\n * Check for element dependencies (select-based, checkbox-based, radio-based).\n *\n * This is the main dependency analysis function that orchestrates the detection of\n * relationships between form elements. It identifies when elements are controlled by\n * other elements (e.g., select values determining field visibility).\n *\n * @param {HTMLElement} element - The element to check for dependencies\n * @returns {Array|null} Array of dependency objects or null if no dependencies found\n */\nconst checkElementDependencies = (element) => {\n    const form = element.closest('form');\n    if (!form) {\n        return null;\n    }\n\n    const elementContainer = element.closest('.fitem');\n    const dependencies = [];\n\n    // Analyze the visibility status of the current element.\n    const visibility = getElementVisibility(element, elementContainer);\n\n    // Find all potential controlling elements within the same form.\n    const controllingElements = form.querySelectorAll('select, input[type=\"checkbox\"], input[type=\"radio\"]');\n\n    controllingElements.forEach((controlElement) => {\n        // Skip self-references and inactive controlling elements.\n        if (controlElement === element ||\n            controlElement.closest('[style*=\"display: none\"]') ||\n            controlElement.hasAttribute('disabled') ||\n            controlElement.disabled) {\n            return;\n        }\n\n        // Analyze the relationship between the current element and potential controller.\n        const dependency = analyzeElementDependency(element, controlElement, visibility);\n        if (dependency) {\n            dependencies.push(dependency);\n        }\n    });\n\n    return dependencies.length > 0 ? dependencies : null;\n};\n\n/**\n * Get element visibility status.\n *\n * Analyzes how an element is hidden or disabled, providing detailed information\n * about the method used to hide the element. This is crucial for understanding\n * dependency relationships.\n *\n * @param {HTMLElement} element - The element to check\n * @param {HTMLElement} container - The container element (.fitem)\n * @returns {Object} Visibility information including hide method and disabled state\n */\nconst getElementVisibility = (element, container) => {\n    let isHidden = false;\n    let hideMethod = 'none';\n\n    if (container) {\n        const style = container.style;\n        const hiddenAttr = container.hasAttribute('hidden');\n        const computedStyle = window.getComputedStyle(container);\n\n        // Check various methods of hiding elements.\n        if (style && style.display === 'none') {\n            isHidden = true;\n            hideMethod = 'style_display';\n        } else if (hiddenAttr) {\n            isHidden = true;\n            hideMethod = 'hidden_attribute';\n        } else if (computedStyle.display === 'none') {\n            isHidden = true;\n            hideMethod = 'computed_style';\n        } else if (computedStyle.visibility === 'hidden') {\n            isHidden = true;\n            hideMethod = 'visibility_hidden';\n        }\n    }\n\n    return {\n        isHidden: isHidden,\n        hideMethod: hideMethod,\n        isDisabled: element.disabled || element.hasAttribute('disabled')\n    };\n};\n\n/**\n * Analyze potential dependency between two elements.\n *\n * This function implements the core logic for detecting dependencies between elements\n * using multiple pattern recognition strategies. It examines naming conventions,\n * container relationships, and semantic associations.\n *\n * @param {HTMLElement} dependentElement - The potentially dependent element\n * @param {HTMLElement} controlElement - The potentially controlling element\n * @param {Object} visibility - Visibility status of dependent element\n * @returns {Object|null} Dependency object or null if no relationship is found\n */\nconst analyzeElementDependency = (dependentElement, controlElement, visibility) => {\n    const controlName = controlElement.name || '';\n    const controlType = controlElement.type || controlElement.tagName.toLowerCase();\n    const controlValue = getControlElementValue(controlElement);\n\n    const dependentName = dependentElement.name || '';\n    const dependentId = dependentElement.id || '';\n\n    // Apply multiple pattern recognition strategies to identify dependencies.\n\n    // Pattern 1: Numeric suffix dependencies (e.g., primer1, instructions1 depend on preset=1).\n    const numericDependency = checkNumericSuffixDependency(dependentName, dependentId, controlName, controlValue);\n    if (numericDependency) {\n        return createDependencyObject(controlElement, controlValue, numericDependency.requiredValue, visibility);\n    }\n\n    // Pattern 2: Semantic name dependencies (mode -> topic/story/activities).\n    const semanticDependency = checkSemanticDependency(dependentName, dependentId, controlName, controlValue);\n    if (semanticDependency) {\n        return createDependencyObject(controlElement, controlValue, semanticDependency.requiredValue, visibility);\n    }\n\n    // Pattern 3: Container-based dependencies using data attributes.\n    const containerDependency = checkContainerDependency(dependentElement, controlElement, controlValue);\n    if (containerDependency) {\n        return createDependencyObject(controlElement, controlValue, containerDependency.requiredValue, visibility);\n    }\n\n    // Pattern 4: Checkbox enable/disable dependencies.\n    const enableDependency = checkEnableDependency(dependentName, dependentId, controlName, controlValue, controlType);\n    if (enableDependency) {\n        return createDependencyObject(controlElement, controlValue, enableDependency.requiredValue, visibility);\n    }\n\n    return null;\n};\n\n/**\n * Check for numeric suffix dependencies (e.g., primer1, instructions1 depend on preset=1).\n *\n * This pattern recognition function identifies dependencies where elements with numeric\n * suffixes depend on select/radio values. Common in scenarios like question presets\n * where different numbered configurations are shown based on selection.\n *\n * @param {string} dependentName - Name of dependent element\n * @param {string} dependentId - ID of dependent element\n * @param {string} controlName - Name of control element\n * @param {string} controlValue - Value of control element\n * @returns {Object|null} Dependency info or null if no pattern matches\n */\nconst checkNumericSuffixDependency = (dependentName, dependentId, controlName, controlValue) => {\n    // Extract numeric suffix from dependent element name or ID.\n    const dependentMatch = dependentName.match(/^(.+?)(\\d+)$/) || dependentId.match(/^id_(.+?)(\\d+)$/);\n    if (!dependentMatch) {\n        return null;\n    }\n\n    const baseName = dependentMatch[1];\n    const number = dependentMatch[2];\n\n    // Normalize control element name for comparison.\n    const controlBaseName = controlName.replace(/^(id_)?/, '').replace(/_$/, '');\n\n    // Define common patterns for numeric dependencies in Moodle forms.\n    const commonPatterns = [\n        { control: 'preset', dependents: ['primer', 'instructions', 'example', 'template', 'config'] },\n        { control: 'mode', dependents: ['option', 'setting', 'param', 'field'] },\n        { control: 'type', dependents: ['config', 'option', 'param', 'setting'] },\n        { control: 'category', dependents: ['subcategory', 'item', 'field'] },\n        { control: 'level', dependents: ['detail', 'item', 'option'] }\n    ];\n\n    // Check if the control and dependent names match any known patterns.\n    for (let i = 0; i < commonPatterns.length; i++) {\n        const pattern = commonPatterns[i];\n        if (controlBaseName === pattern.control && pattern.dependents.indexOf(baseName) !== -1) {\n            // The dependency exists if the number matches the control value.\n            if (number === controlValue) {\n                return { requiredValue: controlValue };\n            }\n        }\n    }\n\n    return null;\n};\n\n/**\n * Check for semantic name dependencies.\n *\n * This function identifies dependencies based on semantic relationships between\n * element names, where certain fields are shown/hidden based on mode selections\n * or similar conceptual groupings.\n *\n * @param {string} dependentName - Name of dependent element\n * @param {string} dependentId - ID of dependent element\n * @param {string} controlName - Name of control element\n * @param {string} controlValue - Value of control element\n * @returns {Object|null} Dependency info or null if no semantic relationship found\n */\nconst checkSemanticDependency = (dependentName, dependentId, controlName, controlValue) => {\n    // Define semantic mappings between control values and dependent field names.\n    const semanticMappings = {\n        'mode': {\n            '1': ['topic', 'subject', 'theme'],\n            '2': ['content', 'story', 'text', 'material'],\n            '3': ['activities', 'courseactivities', 'course_content', 'modules']\n        },\n        'type': {\n            'manual': ['manual_config', 'manual_settings'],\n            'auto': ['auto_config', 'auto_settings'],\n            'custom': ['custom_config', 'custom_settings']\n        },\n        'format': {\n            'html': ['html_editor', 'wysiwyg'],\n            'plain': ['plain_text', 'textarea'],\n            'markdown': ['markdown_editor']\n        }\n    };\n\n    const controlBaseName = controlName.replace(/^(id_)?/, '');\n    const dependentBaseName = dependentName.replace(/^(id_)?/, '');\n\n    // Check if the control element and dependent element match semantic patterns.\n    if (semanticMappings[controlBaseName]) {\n        const valueMapping = semanticMappings[controlBaseName][controlValue];\n        if (valueMapping && valueMapping.indexOf(dependentBaseName) !== -1) {\n            return { requiredValue: controlValue };\n        }\n    }\n\n    return null;\n};\n\n/**\n * Check for container-based dependencies using data attributes.\n *\n * This function looks for explicit dependency declarations in HTML data attributes,\n * which provide a standardized way to declare element relationships in forms.\n *\n * @param {HTMLElement} dependentElement - The dependent element\n * @param {HTMLElement} controlElement - The control element\n * @param {string} controlValue - Value of control element\n * @returns {Object|null} Dependency info or null if no data attributes found\n */\nconst checkContainerDependency = (dependentElement, controlElement, controlValue) => {\n    const container = dependentElement.closest('.fitem');\n    if (!container) {\n        return null;\n    }\n\n    // Check for data-depends-on attribute pointing to the control element.\n    const dependsOn = container.getAttribute('data-depends-on');\n    if (dependsOn === controlElement.name || dependsOn === controlElement.id) {\n        const showWhen = container.getAttribute('data-show-when') || controlValue;\n        return { requiredValue: showWhen };\n    }\n\n    // Check for data-conditional attribute with JSON configuration.\n    const conditional = container.getAttribute('data-conditional');\n    if (conditional) {\n        try {\n            const conditionObj = JSON.parse(conditional);\n            if (conditionObj.element === controlElement.name && conditionObj.value === controlValue) {\n                return { requiredValue: controlValue };\n            }\n        } catch (e) {\n            // Silently ignore JSON parse errors to prevent script breaking.\n        }\n    }\n\n    return null;\n};\n\n/**\n * Check for enable/disable checkbox dependencies.\n *\n * Identifies checkboxes that control the enabled/disabled state of other form elements.\n * This is different from visibility dependencies and focuses on form interaction state.\n *\n * @param {string} dependentName - Name of dependent element\n * @param {string} dependentId - ID of dependent element\n * @param {string} controlName - Name of control element\n * @param {string} controlValue - Value of control element\n * @param {string} controlType - Type of control element\n * @returns {Object|null} Dependency info or null if no enable pattern matches\n */\nconst checkEnableDependency = (dependentName, dependentId, controlName, controlValue, controlType) => {\n    if (controlType !== 'checkbox') {\n        return null;\n    }\n\n    // Define common patterns for enable/disable checkbox naming.\n    const patterns = [\n        dependentName + '_enabled',\n        dependentName + '_enable',\n        'enable_' + dependentName,\n        dependentName.replace(/^id_/, '') + '_enabled'\n    ];\n\n    if (patterns.indexOf(controlName) !== -1) {\n        return { requiredValue: '1' };\n    }\n\n    return null;\n};\n\n/**\n * Get value from control element (select, checkbox, radio).\n *\n * Extracts the current value from different types of form controls,\n * handling the specifics of each input type appropriately.\n *\n * @param {HTMLElement} element - The control element\n * @returns {string} The current value as a string\n */\nconst getControlElementValue = (element) => {\n    const type = element.type || element.tagName.toLowerCase();\n\n    if (type === 'checkbox' || type === 'radio') {\n        // For checkboxes and radios, return '1' if checked, '0' if unchecked.\n        return element.checked ? '1' : '0';\n    } else if (type === 'select' || type === 'select-one' || type === 'select-multiple') {\n        // For select elements, return the selected value.\n        return element.value || '';\n    } else {\n        // For all other input types, return the value directly.\n        return element.value || '';\n    }\n};\n\n/**\n * Create standardized dependency object.\n *\n * This function creates a consistent structure for dependency information\n * that can be used by AI systems to understand form element relationships.\n *\n * @param {HTMLElement} controlElement - The controlling element\n * @param {string} controlValue - Current value of controlling element\n * @param {string} requiredValue - Required value for visibility/enablement\n * @param {Object} visibility - Visibility status object\n * @returns {Object} Standardized dependency object\n */\nconst createDependencyObject = (controlElement, controlValue, requiredValue, visibility) => {\n    return {\n        controllingElement: controlElement.name || '',\n        controllingElementId: controlElement.id || '',\n        controllingType: controlElement.type || controlElement.tagName.toLowerCase(),\n        controllingValue: controlValue,\n        requiredValue: requiredValue,\n        isCurrentlyVisible: !visibility.isHidden && controlValue === requiredValue,\n        hideMethod: visibility.hideMethod\n    };\n};\n\n/**\n * Enhanced dependency analysis that also checks for common JavaScript patterns.\n *\n * This function analyzes CSS classes and JavaScript event handlers to identify\n * additional dependency patterns that may not be captured by DOM structure alone.\n *\n * @param {HTMLElement} element - The element to analyze\n * @returns {Array|null} Array of JavaScript dependency objects or null\n */\nconst analyzeJavaScriptDependencies = (element) => {\n    const container = element.closest('.fitem');\n    if (!container) {\n        return null;\n    }\n\n    const dependencies = [];\n\n    // Analyze CSS classes that indicate dependencies.\n    const classes = container.className.split(' ');\n    classes.forEach((cls) => {\n        // Pattern: depends-on-fieldname, show-when-fieldname-value.\n        if (cls.startsWith('depends-on-')) {\n            const dependencyName = cls.replace('depends-on-', '');\n            dependencies.push({\n                type: 'css_class',\n                pattern: cls,\n                dependsOn: dependencyName\n            });\n        } else if (cls.match(/^show-when-\\w+-\\w+$/)) {\n            const parts = cls.replace('show-when-', '').split('-');\n            if (parts.length >= 2) {\n                dependencies.push({\n                    type: 'css_class',\n                    pattern: cls,\n                    dependsOn: parts[0],\n                    requiredValue: parts.slice(1).join('-')\n                });\n            }\n        }\n    });\n\n    // Prüfe Event-Handler, die auf Änderungen reagieren\n    const form = element.closest('form');\n    if (form) {\n        const scripts = document.querySelectorAll('script');\n        scripts.forEach((script) => {\n            const content = script.textContent || script.innerText;\n            if (content && content.includes(element.name || element.id)) {\n                // Suche nach Event-Handler-Patterns\n                const eventPatterns = [\n                    /addEventListener\\(['\"]change['\"],\\s*function/g,\n                    /\\.on\\(['\"]change['\"],\\s*function/g,\n                    /onchange\\s*=\\s*['\"]?[^'\"]+/g\n                ];\n\n                eventPatterns.forEach((pattern) => {\n                    if (content.match(pattern)) {\n                        dependencies.push({\n                            type: 'javascript_event',\n                            pattern: 'change_listener',\n                            element: element.name || element.id\n                        });\n                    }\n                });\n            }\n        });\n    }\n\n    return dependencies.length > 0 ? dependencies : null;\n};\n\n/**\n * Analyze sibling and parent-child dependencies within form groups.\n *\n * @param {HTMLElement} element - The element to analyze\n * @returns {Object|null} Sibling dependency information\n */\nconst analyzeSiblingDependencies = (element) => {\n    const container = element.closest('.fitem');\n    if (!container) {\n        return null;\n    }\n\n    const dependencies = [];\n    const elementName = element.name || '';\n\n    // Finde Geschwister-Container\n    const siblingContainers = [];\n    const parent = container.parentNode;\n    if (parent) {\n        const allFitems = parent.querySelectorAll('.fitem');\n        allFitems.forEach((fitem) => {\n            if (fitem !== container) {\n                siblingContainers.push(fitem);\n            }\n        });\n    }\n\n    // Analysiere Geschwister auf ähnliche Namen\n    siblingContainers.forEach((siblingContainer) => {\n        const siblingElements = siblingContainer.querySelectorAll('input, select, textarea');\n        siblingElements.forEach((siblingElement) => {\n            const siblingName = siblingElement.name || '';\n\n            // Pattern: Ähnliche Namen mit Suffixen/Präfixen\n            const similarity = analyzeSimilarity(elementName, siblingName);\n            if (similarity.score > 0.7 && similarity.type) {\n                const siblingVisibility = getElementVisibility(siblingElement, siblingContainer);\n\n                dependencies.push({\n                    type: 'sibling_dependency',\n                    siblingElement: siblingName,\n                    siblingId: siblingElement.id || '',\n                    similarity: similarity,\n                    siblingVisible: !siblingVisibility.isHidden\n                });\n            }\n        });\n    });\n\n    return dependencies.length > 0 ? dependencies : null;\n};\n\n/**\n * Analyze similarity between two element names.\n *\n * @param {string} name1 - First element name\n * @param {string} name2 - Second element name\n * @returns {Object} Similarity analysis\n */\nconst analyzeSimilarity = (name1, name2) => {\n    if (!name1 || !name2) {\n        return { score: 0, type: null };\n    }\n\n    // Entferne gemeinsame Präfixe\n    const cleanName1 = name1.replace(/^(id_)?/, '');\n    const cleanName2 = name2.replace(/^(id_)?/, '');\n\n    // Pattern 1: Numerische Suffixe (field1, field2, field3)\n    const numPattern1 = cleanName1.match(/^(.+?)(\\d+)$/);\n    const numPattern2 = cleanName2.match(/^(.+?)(\\d+)$/);\n\n    if (numPattern1 && numPattern2 && numPattern1[1] === numPattern2[1]) {\n        return {\n            score: 0.9,\n            type: 'numeric_series',\n            basePattern: numPattern1[1],\n            numbers: [numPattern1[2], numPattern2[2]]\n        };\n    }\n\n    // Pattern 2: Ähnliche Basis mit verschiedenen Suffixen\n    let commonPrefixLength = 0;\n    for (let i = 0; i < Math.min(cleanName1.length, cleanName2.length); i++) {\n        if (cleanName1[i] === cleanName2[i]) {\n            commonPrefixLength++;\n        } else {\n            break;\n        }\n    }\n\n    if (commonPrefixLength >= 3) {\n        const similarity = commonPrefixLength / Math.max(cleanName1.length, cleanName2.length);\n        return {\n            score: similarity,\n            type: 'similar_prefix',\n            commonPrefix: cleanName1.substring(0, commonPrefixLength)\n        };\n    }\n\n    return { score: 0, type: null };\n};\n\n/**\n * Determine visual visibility of an element based on computed styles.\n *\n * This function analyzes the computed CSS styles to determine if an element\n * is visually visible to the user. It checks multiple CSS properties that\n * can affect visibility including display, visibility, opacity, and dimensions.\n * It also traverses up the DOM tree to check if any parent elements are hidden.\n *\n * @param {HTMLElement} element - The element to check for visual visibility\n * @param {CSSStyleDeclaration} computedStyle - Optional pre-computed style object\n * @returns {boolean} True if the element is visually visible, false otherwise\n */\nconst getElementVisualVisibility = (element, computedStyle) => {\n    // First check if the element itself is hidden by any method.\n    if (!isElementDirectlyVisible(element, computedStyle)) {\n        return false;\n    }\n\n    // Then check if any parent element is hidden.\n    return !hasHiddenParent(element);\n};\n\n/**\n * Check if an element is directly visible (ignoring parent visibility).\n *\n * @param {HTMLElement} element - The element to check\n * @param {CSSStyleDeclaration} computedStyle - Optional pre-computed style object\n * @returns {boolean} True if the element itself is visible\n */\nconst isElementDirectlyVisible = (element, computedStyle) => {\n    // Check for hidden attribute.\n    if (element.hasAttribute('hidden')) {\n        return false;\n    }\n\n    // Use provided computed style or calculate it.\n    const styles = computedStyle || window.getComputedStyle(element);\n\n    // Check if element is hidden via display property.\n    if (styles.display === 'none') {\n        return false;\n    }\n\n    // Check if element is hidden via visibility property.\n    if (styles.visibility === 'hidden') {\n        return false;\n    }\n\n    // Check if element is transparent (opacity 0).\n    const opacity = parseFloat(styles.opacity);\n    if (opacity === 0) {\n        return false;\n    }\n\n    // Check if element has zero dimensions (width or height).\n    const width = parseFloat(styles.width);\n    const height = parseFloat(styles.height);\n    if (width === 0 && height === 0) {\n        return false;\n    }\n\n    // Check if element is clipped to invisible area.\n    const clip = styles.clip;\n    if (clip && clip !== 'auto' && clip.match(/rect\\(0px,?\\s*0px,?\\s*0px,?\\s*0px\\)/)) {\n        return false;\n    }\n\n    // Check if element is positioned offscreen.\n    const position = styles.position;\n    if (position === 'absolute' || position === 'fixed') {\n        const left = parseFloat(styles.left);\n        const top = parseFloat(styles.top);\n        const right = parseFloat(styles.right);\n        const bottom = parseFloat(styles.bottom);\n\n        // Common patterns for hiding elements offscreen.\n        if ((left < -9999 || right < -9999 || top < -9999 || bottom < -9999) ||\n            (left > 9999 || right > 9999 || top > 9999 || bottom > 9999)) {\n        }\n    }\n\n    // Check for text-indent hiding technique.\n    const textIndent = parseFloat(styles.textIndent);\n    if (textIndent < -9999 || textIndent > 9999) {\n        return false;\n    }\n\n    return true;\n};\n\n/**\n * Check if any parent element is hidden.\n *\n * Since we now wait for all JavaScript to execute before analyzing the DOM,\n * we can rely on the current computed styles to accurately reflect visibility.\n *\n * @param {HTMLElement} element - The element whose parents to check\n * @returns {boolean} True if any parent is hidden, false otherwise\n */\nconst hasHiddenParent = (element) => {\n    let parent = element.parentElement;\n\n    while (parent && parent !== document.body && parent !== document.documentElement) {\n        // Check for hidden attribute on parent elements.\n        if (parent.hasAttribute('hidden') || parent.hidden === true) {\n            return true;\n        }\n\n        // Check computed styles of parent elements.\n        const parentStyles = window.getComputedStyle(parent);\n        if (parentStyles.display === 'none' || parentStyles.visibility === 'hidden') {\n            return true;\n        }\n\n        // Check for opacity 0 on parent elements.\n        const parentOpacity = parseFloat(parentStyles.opacity);\n        if (parentOpacity === 0) {\n            return true;\n        }\n\n        parent = parent.parentElement;\n    }\n\n    return false;\n};\n\n/**\n * Populate a hidden field with DOM analysis data.\n *\n * @param {string} hiddenFieldId - ID of the hidden field to populate\n * @param {Object} options - Configuration options\n * @returns {Promise<void>}\n */\nexport const populateHiddenField = async (hiddenFieldId, options = {}) => {\n    try {\n        const elements = await getDomElementsAsJson();\n\n        // Add form metadata\n        const analysisData = {\n            timestamp: new Date().toISOString(),\n            formUrl: window.location.href,\n            formelements: elements,\n            version: '1.0'\n        };\n\n        // Find the hidden field\n        const hiddenField = document.getElementById(hiddenFieldId);\n        if (!hiddenField) {\n            throw new Error(`Hidden field with ID \"${hiddenFieldId}\" not found`);\n        }\n\n        // Populate the field with JSON data\n        hiddenField.value = JSON.stringify(analysisData);\n\n        console.log(`Successfully populated hidden field \"${hiddenFieldId}\" with ${elements.length} form elements`);\n\n    } catch (error) {\n        console.error('Error populating hidden field:', error);\n        throw error;\n    }\n};\n\n/**\n * Setup auto-population of hidden field with debouncing.\n *\n * @param {string} hiddenFieldId - ID of the hidden field to populate\n * @param {Object} options - Configuration options\n * @param {number} debounceMs - Debounce time in milliseconds\n * @returns {Function} Cleanup function to stop auto-population\n */\nexport const autoPopulateHiddenField = (hiddenFieldId, options = {}, debounceMs = 1000) => {\n    let timeoutId = null;\n    let isProcessing = false;\n\n    const updateHiddenField = async () => {\n        if (isProcessing) {\n            return;\n        }\n\n        try {\n            isProcessing = true;\n            await populateHiddenField(hiddenFieldId, options);\n        } catch (error) {\n            console.error('Auto-population failed:', error);\n        } finally {\n            isProcessing = false;\n        }\n    };\n\n    const debouncedUpdate = () => {\n        if (timeoutId) {\n            clearTimeout(timeoutId);\n        }\n        timeoutId = setTimeout(updateHiddenField, debounceMs);\n    };\n\n    // Listen for various form events that might change the DOM\n    const events = ['input', 'change', 'click', 'focus', 'blur', 'DOMSubtreeModified'];\n\n    events.forEach(eventType => {\n        document.addEventListener(eventType, debouncedUpdate, true);\n    });\n\n    // Also listen for window resize in case of responsive layouts\n    window.addEventListener('resize', debouncedUpdate);\n\n    // Initial population\n    updateHiddenField();\n\n    // Return cleanup function\n    return () => {\n        if (timeoutId) {\n            clearTimeout(timeoutId);\n        }\n\n        events.forEach(eventType => {\n            document.removeEventListener(eventType, debouncedUpdate, true);\n        });\n\n        window.removeEventListener('resize', debouncedUpdate);\n\n        console.log('Auto-population cleanup completed');\n    };\n};\n\n/**\n * Make DOM parser globally accessible for console usage.\n *\n * This function exposes the DOM parser functionality globally so it can be\n * called from the browser console for debugging and analysis purposes.\n *\n * Usage in browser console:\n * - window.MoodleDomParser.analyze() - Returns a Promise with DOM analysis\n * - window.MoodleDomParser.analyzeAndLog() - Analyzes and logs to console\n * - window.MoodleDomParser.analyzeAndDisplay() - Analyzes and shows in alert\n */\nexport const makeGloballyAccessible = () => {\n    // Create global namespace if it doesn't exist\n    if (typeof window.MoodleDomParser === 'undefined') {\n        window.MoodleDomParser = {};\n    }\n\n    // Expose populateHiddenField function globally\n    window.MoodleDomParser.populateHiddenField = async (hiddenFieldId, options = {}) => {\n        return await populateHiddenField(hiddenFieldId, options);\n    };\n\n    // Expose autoPopulateHiddenField function globally\n    window.MoodleDomParser.autoPopulateHiddenField = (hiddenFieldId, options = {}, debounceMs = 1000) => {\n        return autoPopulateHiddenField(hiddenFieldId, options, debounceMs);\n    };\n\n    // Main analysis function that returns a Promise\n    window.MoodleDomParser.analyze = async () => {\n        try {\n            const result = await getDomElementsAsJson();\n            return result;\n        } catch (error) {\n            // eslint-disable-next-line no-console\n            console.error('DOM Parser Error:', error);\n            throw error;\n        }\n    };\n\n    // Convenience function that analyzes and logs to console\n    window.MoodleDomParser.analyzeAndLog = async () => {\n        try {\n            const result = await window.MoodleDomParser.analyze();\n            // eslint-disable-next-line no-console\n            console.log('=== Moodle DOM Analysis Results ===');\n            // eslint-disable-next-line no-console\n            console.log('Found', result.formelements ? result.formelements.length : 0, 'form elements');\n            // eslint-disable-next-line no-console\n            console.log('Full data:', result);\n            // eslint-disable-next-line no-console\n            console.log('JSON:', JSON.stringify(result, null, 2));\n            return result;\n        } catch (error) {\n            // eslint-disable-next-line no-console\n            console.error('Failed to analyze DOM:', error);\n            throw error;\n        }\n    };\n\n    // Convenience function that analyzes and shows results in alert\n    window.MoodleDomParser.analyzeAndDisplay = async () => {\n        try {\n            const result = await window.MoodleDomParser.analyze();\n            const elementCount = result.formelements ? result.formelements.length : 0;\n            const jsonString = JSON.stringify(result, null, 2);\n\n            const message = `Moodle DOM Analysis Results:\n\nFound ${elementCount} form elements\n\nJSON Data:\n${jsonString.substring(0, 2000)}${jsonString.length > 2000 ? '...\\n\\n(Data truncated - see console for full output)' : ''}`;\n\n            alert(message);\n\n            // Also log full data to console\n            // eslint-disable-next-line no-console\n            console.log('Full DOM Analysis Data:', result);\n\n            return result;\n        } catch (error) {\n            alert('Error analyzing DOM: ' + error.message);\n            // eslint-disable-next-line no-console\n            console.error('DOM analysis error:', error);\n            throw error;\n        }\n    };\n\n    // Add help function\n    window.MoodleDomParser.help = () => {\n// eslint-disable-next-line no-console\n        console.log(`\n === Moodle DOM Parser Console Commands ===\n\n Available functions:\n • window.MoodleDomParser.analyze()              - Returns Promise with DOM analysis data\n • window.MoodleDomParser.analyzeAndLog()        - Analyzes and logs results to console\n • window.MoodleDomParser.analyzeAndDisplay()    - Analyzes and shows results in alert\n • window.MoodleDomParser.populateHiddenField()  - Populates hidden field with analysis data\n • window.MoodleDomParser.autoPopulateHiddenField() - Setup auto-population with debouncing\n • window.MoodleDomParser.help()                 - Shows this help message\n\n Examples:\n // Basic analysis\n await window.MoodleDomParser.analyze()\n\n // Quick analysis with console output\n await window.MoodleDomParser.analyzeAndLog()\n\n // Analysis with popup display\n await window.MoodleDomParser.analyzeAndDisplay()\n\n // Populate hidden field with ID \"form_analysis\"\n await window.MoodleDomParser.populateHiddenField(\"form_analysis\")\n\n // Setup auto-population with 2 second debounce\n const cleanup = window.MoodleDomParser.autoPopulateHiddenField(\"form_analysis\", {}, 2000)\n\n // Get specific element data\n const data = await window.MoodleDomParser.analyze()\n console.log('Visible elements:', data.formelements.filter(el => el.visible === 1))\n console.log('Hidden elements:', data.formelements.filter(el => el.visible === 0))\n         `);\n    };\n\n    // eslint-disable-next-line no-console\n    console.log('✅ Moodle DOM Parser is now globally accessible!');\n    // eslint-disable-next-line no-console\n    console.log('📖 Type \"window.MoodleDomParser.help()\" for usage instructions');\n};\n"],"names":["getDomElementsAsJson","Promise","resolve","extractDomElements","elements","contentDiv","document","getElementById","querySelectorAll","forEach","node","type","tagName","toLowerCase","currentValue","options","checked","value","style","display","id","tinyFrame","querySelector","contentDocument","tinyBody","body","textContent","innerText","e","selectedOptions","length","isWithinDateTimeContainer","option","push","text","selected","label","findLabelForElement","helptext","findHelptextForElement","active","isDisabled","dependsOnEnabled","disabled","attrNode","getAttributeNode","_node$getAttributeNod","specified","computedStyle","window","getComputedStyle","isVisuallyVisible","getElementVisualVisibility","enabledDependency","checkEnabledDependency","checkboxName","isEnabled","allDependencies","checkElementDependencies","jsDependencies","analyzeJavaScriptDependencies","siblingDependencies","analyzeSiblingDependencies","elementData","name","current_value","visible","depends_on_enabled","dependencies","js_dependencies","sibling_dependencies","element","labelElement","trim","parentLabel","closest","fitemDiv","labelDiv","getAttribute","searchContainers","parentElement","container","helpAnchor","rawHelp","tmpDiv","createElement","innerHTML","elementName","patterns","replace","nameParts","split","i","baseName","slice","join","enabledName","enabledCheckbox","checkboxId","fitemContainer","match","groupCheckboxes","gc","groupCheckbox","indexOf","form","elementContainer","visibility","getElementVisibility","controlElement","hasAttribute","dependency","analyzeElementDependency","isHidden","hideMethod","hiddenAttr","dependentElement","controlName","controlType","controlValue","getControlElementValue","dependentName","dependentId","numericDependency","checkNumericSuffixDependency","createDependencyObject","requiredValue","semanticDependency","checkSemanticDependency","containerDependency","checkContainerDependency","enableDependency","checkEnableDependency","dependentMatch","number","controlBaseName","commonPatterns","control","dependents","pattern","semanticMappings","dependentBaseName","valueMapping","dependsOn","conditional","conditionObj","JSON","parse","controllingElement","controllingElementId","controllingType","controllingValue","isCurrentlyVisible","className","cls","startsWith","dependencyName","parts","script","content","includes","siblingContainers","parent","parentNode","fitem","siblingContainer","siblingElement","siblingName","similarity","analyzeSimilarity","score","siblingVisibility","siblingId","siblingVisible","name1","name2","cleanName1","cleanName2","numPattern1","numPattern2","basePattern","numbers","commonPrefixLength","Math","min","max","commonPrefix","substring","isElementDirectlyVisible","hasHiddenParent","styles","parseFloat","opacity","width","height","clip","position","left","top","right","bottom","textIndent","documentElement","hidden","parentStyles","populateHiddenField","async","hiddenFieldId","analysisData","timestamp","Date","toISOString","formUrl","location","href","formelements","version","hiddenField","Error","stringify","console","log","error","autoPopulateHiddenField","debounceMs","timeoutId","isProcessing","updateHiddenField","debouncedUpdate","clearTimeout","setTimeout","events","eventType","addEventListener","removeEventListener","MoodleDomParser","analyze","analyzeAndLog","result","analyzeAndDisplay","elementCount","jsonString","message","alert","help"],"mappings":"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"}